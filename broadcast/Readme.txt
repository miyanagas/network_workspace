====================================================
    Readme.txt
====================================================

=== プログラムの使用法 ===
1. ユーザ名（英文字15文字以内）と待ち受けポート番号（省略時は50001）をコマンドラインで指定し、プログラムを起動する。
2. はじめ、プログラムはクライアントとして起動し、まずサーバの探索を行う。
3. ネットワーク内にサーバがいなければ、"Server startup:)"と表示され、自らがサーバになる。
4. ネットワーク内にサーバがいれば、"Server is here[(アドレス)]"と表示され、そのままクライアントを続行する。

~~~ サーバ ~~~
1. 複数のクライアントからの接続を受けつける。
2. クライアントが接続してきたら、"[INFO] join user!"というメッセージと現在接続中のクライアント数が表示される。
 また、接続してきたクライアントのユーザ名が表示される。（ユーザ名が適切に登録されなかった場合、表示されない。）
3. ユーザにより送信された発言メッセージが逐次表示される。
 （発言メッセージの先頭には発言者の識別のためユーザ名が表記される。ユーザ名が適切に登録されなかった場合、"unknown"と表記される。）
4. サーバもクライアントのユーザと同じようにメッセージを送ることで井戸端会議に参加できる。
5. クライアントが接続を終了した場合、"[INFO] (ユーザ名) leave..."というメッセージと現在接続中のクライアント数が表示される。
 （ユーザ名が適切に登録されなかった場合、"[INFO] unknown leave..."と表示される。）

~~~ クライアント ~~~
1. サーバに接続する。接続したら"Connected to Server:)"と表示される。
2. メッセージを送ることで、同じサーバに接続しているクライアントのユーザまたサーバのユーザと井戸端会議を楽しむことができる。
 同じサーバに接続しているクライアントのユーザ、サーバのユーザから送られてきた発言メッセージは先頭にユーザ名が付加され"[(ユーザ名)] (発言メッセージ)"という形式で表示される。
3. 途中でユーザが参加してきた場合、"[INFO] join (ユーザ名)!"という通知が表示される。また、途中でユーザが離席した場合、"[INFO] (ユーザ名) leave..."という通知が表示される。
4. 終了したい場合は、"QUIT"というメッセージを送信することで接続を閉じプログラムを終了することができる。正常にプログラムを終了した場合、"Bye Bye:)"というメッセージが表示される。
5. 何らかの理由によりサーバがダウンしてしまった場合、"Server is down:("と表示され接続が終了しプログラムが終了する。

=== プログラムの特徴と苦労した点 ===

　このプログラムは仕様を満たすように厳重に作成した。
例えば、ユーザ名はプログラムの起動時にコマンドラインから指定するが、ユーザ名が15文字以内になるよう関数snprintfを使用し工夫した。
（関数snprintfは書き込む文字列の最大文字数（終端のヌル文字を含む）を指定することができる）
同様に、サーバ側でJOINパケットで受信するユーザ名は15文字を超える文字数のユーザ名を受け取る可能性があるので、15文字以内になるよう関数snprintfを使用した。
発言メッセージは同じように488バイト以内になるように関数fgetsを使用し工夫した。
（関数fgetsも関数snprintfと同じように書き込む文字列の最大文字数（終端のヌル文字を含む）を指定することができる）
　また、このプログラムは現在の状態をできるだけユーザにわかりやすく伝えるために工夫した。
例えば、プログラム起動時、HELOパケットが最大3回ブロードキャストされるが、
その進行状況がわかるようにHELOパケット1回のブロードキャストに対して"----------"を表示する。
サーバからHEREパケットを受け取ったら、"Server is here[(アドレス)]"と表示し、サーバが見つからず自身がサーバとなったら、"Server startup:)"と表示する。
その他にもクライアントとして動作しているときにサーバに接続したら、"Connected to Server:)"と表示されたり、
新たにユーザが井戸端会議に参加したら、"[INFO] join (ユーザ名)!"と通知が表示されたり、
井戸端会議から離席したユーザがいたら、"[INFO] (ユーザ名) leave..."と通知が表示されたり、と逐次ユーザに現在の状況がわかるように工夫した。
　そして、クライアントの情報を管理するデータ構造として線形リストを採用した。この線形リストは、先頭にダミー要素を持ち、その後ろにクライアントの情報を持った要素が続く。
この線形リストは各クライアントのソケットディスクリプタの値をキーとしてソケットディスクリプタの値が大きいものから降順に並ぶ。
そうすることで、select()を利用してパケットの到着監視をするときに必要となるソケットディスクリプタ番号の最大値に簡単にアクセスできるように工夫した。
　これらの実装では、特に線形リストの実装とクライアントの不具合によって動作に問題が生じてしまわないようなサーバの実装がとても苦労した。
線形リストの実装はデータをソケットディスクリプタの値をキーとして降順に並べる実装とログアウト処理のデータ削除の実装に苦労した。